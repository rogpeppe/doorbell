// build tags derived from:
// 	grep -L TRNG device/sam/*.go

// +build at91sam9cn11 at91sam9cn12 at91sam9m10 at91sam9m11 at91sam9n12 atsam3a4c atsam3a8c atsam3x4c atsam3x4e atsam3x8c atsam3x8e atsam3x8h atsama5d31 atsama5d33 atsama5d34 atsama5d35 atsamd51g18a atsamd51g19a atsamd51j18a atsamd51j19a atsamd51j20a atsamd51n19a atsamd51n20a atsamd51p19a atsamd51p20a atsaml11d14a atsaml11d15a atsaml11d16a atsaml11e14a atsaml11e15a atsaml11e16a atsamv71j19 atsamv71j19b atsamv71j20 atsamv71j20b atsamv71j21 atsamv71j21b atsamv71n19 atsamv71n19b atsamv71n20 atsamv71n20b atsamv71n21 atsamv71n21b atsamv71q19 atsamv71q19b atsamv71q20 atsamv71q20b atsamv71q21 atsamv71q21b

package rand

import (
	"device/sam"
	"encoding/binary"
	"runtime/interrupt"
	"sync"
)

var (
	initOnce sync.Once
	randc    = make(chan uint32, 8)
)

func init() {
	Reader = hwReader{}
}

type hwReader struct{}

func (hwReader) Read(buf []byte) (int, error) {
	var randData [4]byte
	n := 0
	for n < len(buf) {
		x, ok := getUint32(n == 0)
		if !ok {
			// We've failed to get a number, which can only happen
			// if blocking is false, in which case we've already
			// got some data.
			break
		}
		binary.LittleEndian.PutUint32(randData[:], x)
		n += copy(buf[n:], randData[:])
	}
	return n, nil
}

// Note on the flow control:
//
// We want to avoid using unneeded resources in the interrupt handler, so
// we want to disable interrupts when nothing is using the random number
// generator.
//
// There is a danger that by disabling the interrupts, we end up with a deadlock
// if getUint32 tries to read from the channel with interrupts disabled.
//
// In the scheme below, the reader enables the interrupt before reading when
// the channel isn't full, and the interrupt handler disables itself when it sees
// that the channel is full.
//
// An argument for absence of deadlock:
//
// Whenever the interrupt is enabled, there can be no deadlock (the
// handler will continue putting events into the queue). Deadlock can
// only happen when interrupts are disabled, but interrupts are only
// disabled when the channel is full, and when that happens, there are
// cap(chan) available items to read from the channel, and each of them
// will (redundantly) enable interrupts, preventing deadlock.

// getUint32 returns a uint32 value generated by the hardware random
// number generator and reports whether it succeeded. It will always
// succeed if blocking is true.
func getUint32(blocking bool) (uint32, bool) {
	initOnce.Do(setup)
	if len(randc) < cap(randc) {
		// Enable interrupts.
		sam.TRNG.INTENSET.SetBits(sam.TRNG_INTENSET_DATARDY)
	}
	if !blocking {
		select {
		case x := <-randc:
			return x, true
		default:
			return 0, false
		}
	}
	return <-randc, true
}

func setup() {
	// Enable Main Clock for TRNG.
	sam.MCLK.APBCMASK.SetBits(sam.MCLK_APBCMASK_TRNG_)

	// Set up the TRNG interrupt handler.
	interrupt.New(sam.IRQ_TRNG, handleTRNG).Enable()

	// Enable TRNG.
	sam.TRNG.CTRLA.SetBits(sam.TRNG_CTRLA_ENABLE)
}

func handleTRNG(interrupt.Interrupt) {
	// We've got a random number. Put it into the channel if we can,
	// and disable interrupts if the channel fills up.
	canSend := false
	select {
	case randc <- sam.TRNG.DATA.Get():
		canSend = len(randc) < cap(randc)
	default:
		// This shouldn't happen, as we only enable interrupts
		// when there's room enough in the channel for the next value,
		// but better to be sure so we don't block accidentally.
	}
	if !canSend {
		// Disable interrupts.
		sam.TRNG.INTENCLR.SetBits(sam.TRNG_INTENCLR_DATARDY)
	}
}
